<DOCTYPE html>
    <html>

    <head>
        <meta charset="utf-8">
        <title>webgl test</title>
    </head>

    <body>
        <script type="module">
            import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.117.1/build/three.module.js';
            import {OBJLoader} from "https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/loaders/OBJLoader.js";
            import {TextureLoader} from "https://cdn.jsdelivr.net/npm/three@0.117.1/src/loaders/TextureLoader.js";
            
            import {BufferGeometryUtils} from "https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/utils/BufferGeometryUtils.js";
            import {MTLLoader} from "https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/loaders/MTLLoader.js";
            import {EffectComposer} from 'https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/postprocessing/EffectComposer.js';
            import {RenderPass} from 'https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/postprocessing/RenderPass.js';
            import {GlitchPass} from 'https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/postprocessing/GlitchPass.js';
            import {UnrealBloomPass} from 'https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/postprocessing/UnrealBloomPass.js';
            const loafmat = "https://cdn.jsdelivr.net/gh/Alexanderssssss/nerep@main/longloaf1.mtl";
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 3;
            camera.position.z = 5;
            

            camera.rotation.x = 50;
            camera.rotation.y ;
            const renderer = new THREE.WebGLRenderer({antialias:true});

            const basicmaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                wireframe: true
            });
            const loader = new THREE.TextureLoader();
            const texture = loader.load ('http://192.168.4.116:8000/texture.png')

            let material1 = new THREE.MeshStandardMaterial({map: texture});
            let geometry1 = new THREE.BoxBufferGeometry();
            let geometry2 = new THREE.BoxBufferGeometry();
            geometry1.scale(5,1,5)
            let mesh1 = new THREE.Mesh(geometry1, material1);
            geometry2.translate(0,1,0);
            
            let mesh2 = new THREE.Mesh(geometry2, material1);
            mesh2.position.y += 1;
            mesh1.castShadow = true;
            mesh2.castShadow = true;
            mesh1.receiveShadow = true;
            mesh2.receiveShadow = true;

            let twogeometries = BufferGeometryUtils.mergeBufferGeometries([geometry1,geometry2]);
            mesh2 = new THREE.Mesh(twogeometries,material1);
            mesh2.receiveShadow = true;
            mesh2.castShadow = true;

            //scene.add(mesh1);
            //scene.add(mesh2);
            scene.add(mesh2);
            //scene.add(new THREE.Mesh(new THREE.CubeGeometry(1,1,1), material))

            const color = 0xFFFFFF;
            const intensity = 0.4;
            const light = new THREE.AmbientLight(color, intensity);
            scene.add(light);


            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            //scene.add(new THREE.Mesh(new THREE.SphereGeometry(16, 32, 16), basicmaterial));
            let dirlight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirlight.position.x = -1;
            dirlight.position.y = 1;
            dirlight.position.z = 1;
            dirlight.castShadow = true;
            dirlight.target = new THREE.Object3D();
            
            scene.add(dirlight);

            dirlight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirlight.position.x = 0;
            dirlight.position.y = 1;
            dirlight.castShadow = true;
            dirlight.position.z = 1;


            const composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.renderToScreen = true;
            const params = {
                exposure: 1,
                bloomStrength: 0.2,
                bloomThreshold: 0,
                bloomRadius: 0
            };
            bloomPass.threshold = params.bloomThreshold;
            bloomPass.strength = params.bloomStrength;
            bloomPass.radius = params.bloomRadius;
            composer.addPass(bloomPass);

            function animate() {
                requestAnimationFrame(animate);
                //mesh.rotation.x += 0.05;
                mesh2.rotation.y += 0.01;
                composer.render();
            };
            animate();
        </script>
    </body>

    </html>