<DOCTYPE html>
    <html>

    <head>
        <meta charset="utf-8">
        <title>Game</title>
        <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
                    "three/": "https://unpkg.com/three@0.149.0/"
                }
            }
        </script>
        <script src="http://mrdoob.github.io/stats.js/build/stats.min.js"></script>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
            html, body {
                height: 100%;
            }
            body {
                margin: 0;
            }
            .flex-container {
                position: absolute;
                top: 0%;
                left: 40%;
                height: 100%;
                padding: 0;
                margin: 0;
                display: -webkit-box;
                display: -moz-box;
                display: -ms-flexbox;
                display: -webkit-flex;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .row {
                width:120px;
            }
            .column{
                height: 100px;
                width: 250px;
                margin-top: 20px;
            }
            .logbutton {
                position: absolute;
                image-rendering: pixelated;
                color: burlywood;
                font-weight: bold;
                text-align: center;
                background: center / contain no-repeat url("interface/button.png");
                width: 235px;
                height: 80px;
                margin-left: auto;
                margin-right: auto;
                border: none;
                font-size: 36px;
                font-family: 'VT323', monospace;
                transition: 0.2s;
            }
            .logbutton:active{
                transform: scaleX(1.1)scaleY(1.1);
            }
            .soundbutton{
                position: absolute;
                top: 90%;
                left: 2%;
            }
            .musicbutton{
                position: absolute;
                top: 80%;
                left: 2%;
            }
            .smallbutton {
                position: absolute;
                image-rendering: pixelated;
                color: burlywood;
                font-weight: bold;
                text-align: center;
                background: center / contain no-repeat url("interface/small_button.png");
                width: 72px;
                height: 64px;
                border: none;
                font-size: 36px;
                font-family: 'VT323', monospace;
                transition: 0.1s;
            }
            .soundimage,.musicimage{
                transition: 0.15s;
                position: absolute;
                left: 20px;
                top: 4px;
                image-rendering: pixelated;
                width: 36px;
                height: 56px;
                background: center / contain no-repeat url("interface/sound.png");
            }
            .soundimage:active,.musicimage:active,.menu-button:active, .levels:hover{
                transform: scaleX(1.1) scaleY(1.1);
            }
            .musicimage{
                background: center / contain no-repeat url("interface/music.png");
                width: 52px;
                height: 40px;
                left: 10px;
                top: 10px;
            }
            .title{
                content: ".  Beaver Saver";
                position: absolute;
                top: 10%;
                transform: translateX(50px);
                display: block;
                color: #ffcd8d ;
                background-color: #4b3416DD;
                border-radius:10px;
                width: 450px;
                height: 64px;
                border: none;
                font-weight: bold;
                font-size: 72px;
                font-family: 'VT323', monospace;
            }
            .title-levels{
                position: absolute;
                top: 5%;
                transform: translateX(50px);
                display: block;
                color: burlywood;
                width: 450px;
                height: 64px;
                border: none;
                font-weight: bold;
                font-size: 72px;
                font-family: 'VT323', monospace;
            }
            .menu-button{
                position: absolute;
                image-rendering: pixelated;
                color: burlywood;
                font-weight: bold;
                text-align: center;
                background: center / contain no-repeat url("interface/button.png");
                width: 235px;
                height: 80px;
                margin-left: auto;
                margin-right: auto;
                border: none;
                font-size: 50px;
                font-family: 'VT323', monospace;
                transition: 0.1s;
                top: 6%;
                left: 2%;
            }
            .levels{
                position: absolute;
                image-rendering: pixelated;
                color: burlywood;
                font-weight: bold;
                text-align: center;
                background: center / contain no-repeat url("interface/small_button.png");
                width: 100px;
                height: 80px;
                border: none;
                font-size: 36px;
                font-family: 'VT323', monospace;
                transition: 0.1s;
            }
            #level1{
                position: absolute;
                image-rendering: pixelated;
                color: burlywood;
                font-weight: bold;
                text-align: center;
                height: 80px;
                font-size: 36px;
                font-family: 'VT323', monospace;
                transition: 0.1s;
            }
            .level-container {
                position: absolute;
                top: 0%;
                left: 10%;
                height: 100%;
                padding: 0;
                margin: 0;
                display: -webkit-box;
                display: -moz-box;
                display: -ms-flexbox;
                display: -webkit-flex;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .lefthandbutton{
                position: absolute;
                transform: scaleX(1.3) scaleY(1.3);
                top: 85%;
                left: 87%;
            }
            .righthandbutton{
                transform: scaleX(1.3) scaleY(1.3);
                position: absolute;
                top: 70%;
                left: 90%;
            }
            .lefthandimage{
                transition: 0.15s;
                position: absolute;
                left: 4px;
                top: 0px;
                
                image-rendering: pixelated;
                width: 64px;
                height: 64px;
                background: center / contain no-repeat url("interface/log_icon.png");
            }
            .lefthandimage:active,.righthandimage:active{
                transform: scaleX(1.1) scaleY(1.1);
            }
            .righthandimage{
                background: center / contain no-repeat url("interface/music1.png");
                position: absolute;
                transition: 0.15s;
                image-rendering: pixelated;
                width: 52px;
                height: 40px;
                left: 10px;
                top: 10px;
            }
            .pausebutton{
                position: absolute;
                image-rendering: pixelated;
                top: 3%;
                left: 2%;
                color: burlywood;
                font-weight: bold;
                text-align: center;
                background: center / contain no-repeat url("interface/Pause.png");
                width: 2.5em;
                height: 2.5em;
                border: none;
                font-size: 36px;
                font-family: 'VT323', monospace;
                transition: 0.1s;
            }
            .pausebutton:active{
                transform: scaleX(1.1) scaleY(1.1);
            }
            .objective{
                position: absolute;
                top: 3%;
                left: 60%;
                display: block;
                color: rgb(255, 212, 157);
                width: 540px;
                height: 90px;
                border: none;
                font-weight: bold;
                font-size: 36px;
                font-family: 'VT323', monospace;
                background-color: #ffffff3a;
                border-radius: 15px;
            }
            .statsinfo{
                color:rgb(255, 53, 18);
                font-size: 40px;
            }
          </style>  
        </style>
    </head>

    <body>
        <div class="UI">

            <div class="MenuUI">
                <div class="flex-container">
                    <div class="title">‎ ‎Beaver Saver!</div>
                    <div class="row"> 
                        <div class="column">
                            <input type="button" class="logbutton" id="Play" value="Play">    
                        </div>
                        <div class="column">
                            <input type="button" class="logbutton" value="   Settings"> 
                        </div>
                    </div>
                </div>
                <div class="soundbutton">
                    <input type="button" class="smallbutton" value=""> 
                    <div class="soundimage"></div>
                </div>
                <div class="musicbutton">
                    <input type="button" class="smallbutton" value=""> 
                    <div class="musicimage"></div>
                </div>
            </div>

            <div class="levelsUI">
                <input type="button" class="menu-button" id="Menu" value=" Menu"> 
                <div class="level-container">
                    <div class="title-levels">Choose Level</div>
                    <div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level1" value="1">    
                        </div>
                    </div>
                    <div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level2" value="2">    
                        </div>
                    </div>
                    <div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level3" value="3">    
                        </div>
                    </div>
                    <div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level4" value="4">    
                        </div>
                    </div><div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level5" value="5">    
                        </div>
                    </div><div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level6" value="6">    
                        </div>
                    </div><div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level7" value="7">    
                        </div>
                    </div><div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level8" value="8">    
                        </div>
                    </div>
                    <div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level9" value="9">    
                        </div>
                    </div>
                    <div class="row"> 
                        <div class="column">
                            <input type="button" class="levels level10" value="10">    
                        </div>
                    </div>
                </div>
                <div class="soundbutton">
                    <input type="button" class="smallbutton" value=""> 
                    <div class="soundimage"></div>
                </div>
                <div class="musicbutton">
                    <input type="button" class="smallbutton" value=""> 
                    <div class="musicimage"></div>
                </div>
            </div>
        
            <div class="ingameUI">
                <div class="lefthandbutton">
                    <input type="button" class="smallbutton"  value=""> 
                    <div class="lefthandimage"></div>
                </div>
              <!--  <div class="righthandbutton">
                    <input type="button" class="smallbutton" value=""> 
                    <div class="righthandimage"></div>
                </div>-->
                <input type="button" class="pausebutton" value=""> 
                <div class="objective">Neque porro: quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit...</div>
            </div>
        </div>
        <script type="module">
            import * as THREE from 'three';
            import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js'
            import { TextureLoader } from "three/src/loaders/TextureLoader.js";
            import { ImageLoader } from "three/src/loaders/ImageLoader.js";
            import * as BufferGeometryUtils from "three/examples/jsm/utils/BufferGeometryUtils.js";
            import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
            import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
            const delay = ms => new Promise(res => setTimeout(res, ms));
            
            let objLoader, textureLoader, mtlLoader, imageLoader;  
            let scene, camera, renderer, composer;
            let blocksTexture, modelsTexture, waterTexture1, waterTexture2, borderTexture; 
            let blocksMaterial, modelsMaterial, waterMaterial1, waterMaterial2, borderMaterial;
            let waterMesh1, waterMesh2, landscapeMesh;
            let MainHero;
            let HouseModels = [];
            let FenceModel;
            let WaterlilyModel;
            let UnderwaterGrassModel;
            let TreeModel;
            let PineTreeModel;
            let LogModel;
            let BridgeModel;
            let isWaterAnimated = false;

            let clouds = [];
            let waterfallLayers = [];
            let currentLevel; 
            let map;
            let entities;
            
            let ambientLight, directionalLight, lightTarget;
            let uvOffset = 0.125;

            let generateVillage = true;
            let villageRadius = 8;
            let housesRange = [4,4];
            let LevelSize = 128;
            let cloudsAmount = LevelSize*7;
            let TreeDensity = 0.02;
            let currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/testlevel_colored.png';
            let HeightNoiseRange = [6,6];
            let HeightTemplateRange = [8,8];
            let waterLevel = 4; 
            let cameraoffset = new THREE.Vector3(0,5,4.5);
            let VillageHouses = [];
            let walls = []; //collision
            let ModelsIngame =[];
            let TreesLeft = 0;
            let LogsInInv = 0;

            let HeightMap;
            const Block = createEnum(['Air','Grass', 'Dirt','Road']);
            const Entity = createEnum(['Empty','NotPlaceable', 'House','Waterlily', 'VerticalFence','HorizontalFence','UnderwaterGrass','Tree','PineTree','Log','Bridge']);
            currentLevel = '0';
            initLoaders();

            let UI = document.querySelector(".UI");
            let MenuUI = document.querySelector(".MenuUI");
            let levelsUI = document.querySelector(".levelsUI");
            let ingameUI = document.querySelector(".ingameUI");
            let GameInfo = ingameUI.querySelector(".objective");
            function FromMenuToLevelsList(){
                MenuUI.remove()
                UI.appendChild(levelsUI);
            }
            MenuUI.querySelector("#Play").addEventListener("click",FromMenuToLevelsList);
            function FromLevelsListToMenu(){
                levelsUI.remove()
                UI.appendChild(MenuUI);
            }
            levelsUI.querySelector("#Menu").addEventListener("click",FromLevelsListToMenu);
            function FromLevelstoIngame(){
                currentLevel = this.value;
                levelsUI.remove();
                LevelManager(this.value);

            }
            function FromIngameToMenu(){
                ingameUI.remove();
                UI.appendChild(MenuUI);
                LevelManager('0');
                currentLevel = '0';
            }
            function TryToBuild(){
                if(LogsInInv>=3){
                        nextIsBridge = true;
                        LogsInInv -= 3 ;
                        UpdateGameInfo();
                }
            }
            let handimage = ingameUI.querySelector(".lefthandimage");
            console.log(handimage);
            handimage.addEventListener("click",TryToBuild);
            //.addEventListener("click",FromLevelstoLevel)

            for(let i of levelsUI.querySelectorAll(".levels")){
                i.addEventListener("click",FromLevelstoIngame);
            } 
            ingameUI.querySelector('.pausebutton').addEventListener("click",FromIngameToMenu);


            ingameUI.remove();
            levelsUI.remove();
            await LevelManager(currentLevel);
            ingameUI.remove();

            // Adding stats panel to moniter application statistics
            const stats = new Stats();
            stats.showPanel(0);
            //stats.showPanel(1)
            ///document.body.appendChild(stats.dom)
            animate();

            async function LevelManager(level){
                try {
                    renderer.domElement.remove();
                while (scene.children.length)
                {
                    scene.remove(scene.children[0]);
                }
                } catch (error) {
                console.error(error);
                }
                
                clouds = [];
                waterfallLayers = [];
                VillageHouses = [];
                TreesLeft = 0;
                LogsInInv = 0;
                switch(level){
                    case '0':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 16;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/testlevel_colored.png';
                        HeightNoiseRange = [4,6];
                        HeightTemplateRange = [3,3];
                        waterLevel = 4; 
                        TreeDensity = 0.02;
                        break;
                    case '1':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 30;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/empty.png';
                        HeightNoiseRange = [8,8];
                        HeightTemplateRange = [1,1];
                        waterLevel = 4; 
                        TreeDensity = 0.03;
                    case '2':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 34;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/empty.png';
                        HeightNoiseRange = [11,11];
                        HeightTemplateRange = [1,1];
                        waterLevel = 4; 
                        TreeDensity = 0.03;
                        break;

                    case '3':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 30;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/empty.png';
                        HeightNoiseRange = [11,11];
                        HeightTemplateRange = [1,1];
                        waterLevel = 7; 
                        TreeDensity = 0.05;
                        break;
                    case '4':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 32;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/empty.png';
                        HeightNoiseRange = [21,21];
                        HeightTemplateRange = [1,1];
                        waterLevel = 8; 
                        TreeDensity = 0.05;
                        break;
                    case '5':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 30;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/level5.png';
                        HeightNoiseRange = [4,4];
                        HeightTemplateRange = [3,3];
                        waterLevel = 3; 
                        TreeDensity = 0.05;
                        break;
                    case '6':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 52;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/level6.png';
                        HeightNoiseRange = [3,3];
                        HeightTemplateRange = [5,5];
                        waterLevel = 4; 
                        TreeDensity = 0.03;
                        break;
                    case '7':
                        generateVillage = false;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 52;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/level7.png';
                        HeightNoiseRange = [3,3];
                        HeightTemplateRange = [5,5];
                        waterLevel = 4; 
                        TreeDensity = 0.03;
                        break;
                    case '8':
                        generateVillage = true;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 128;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/level8.png';
                        HeightNoiseRange = [6,6];
                        HeightTemplateRange = [8,9];
                        waterLevel = 4; 
                        break;
                        break;
                    case '9':
                        generateVillage = true;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 128;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/level9.png';
                        HeightNoiseRange = [6,6];
                        HeightTemplateRange = [8,9];
                        waterLevel = 4; 
                        break;
                    default: 
                        generateVillage = true;
                        villageRadius = 8;
                        housesRange = [4,4];
                        LevelSize = 128;
                        currentLevelURL = 'https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/testlevel_colored.png';
                        HeightNoiseRange = [6,6];
                        HeightTemplateRange = [8,9];
                        waterLevel = 4; 
                        break;
                }
                ModelsIngame =  [];
                for (let i = 0; i < LevelSize; i++) {
                    ModelsIngame[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        ModelsIngame[i][j] = [];
                    }
                }
                cloudsAmount = LevelSize*5;
                await loadLevel(level);
                
                levelsUI.remove();
                UI.appendChild(ingameUI);
                if(level=='0'){
                    scene.remove(MainHero);
                    levelsUI.remove();
                    ingameUI.remove();
                    UI.appendChild(MenuUI);
                }
                UpdateGameInfo();
            }
            async function loadLevel(level){
                await initScene();
                let noise = await LoadImageToArray('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/perlin_scale18_detail3.png',1);
                noise = MapRange(noise,getRandomInt(HeightNoiseRange[0],HeightNoiseRange[1]));
                let maxOffset =  noise[0].length - LevelSize;
                let OffsetX = getRandomInt(0,maxOffset);
                let OffsetZ = getRandomInt(0,maxOffset);
                let levelHeightNoise =  [];
                for (let i = 0; i < LevelSize; i++) {
                    levelHeightNoise[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        levelHeightNoise[i][j] = noise[i+OffsetX][j+OffsetZ];
                    }
                }
                let template = await LoadImageToArray(currentLevelURL,1);
                template = MapRange(template,getRandomInt(HeightTemplateRange[0],HeightTemplateRange[1]));
                maxOffset =  template[0].length - LevelSize;
                OffsetX = getRandomInt(0,maxOffset);
                OffsetZ = getRandomInt(0,maxOffset);
                let levelHeightTemplate =  [];
                for (let i = 0; i < LevelSize; i++) {
                    levelHeightTemplate[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        levelHeightTemplate[i][j] = template[i+OffsetX][j+OffsetZ];
                    }
                }

                let villagetemplate = await LoadImageToArray(currentLevelURL,0);
                villagetemplate = MapRange(villagetemplate,100);
                let villageSpawnPoints = 0;
                let villagelevelTemplate =  [];
                for (let i = 0; i < LevelSize; i++) {
                    villagelevelTemplate[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        villagelevelTemplate[i][j] = villagetemplate[i+OffsetX][j+OffsetZ];
                        if(villagelevelTemplate[i][j]>98) villageSpawnPoints++;
                    }
                }
                let spawnPoint = getRandomInt(0,villageSpawnPoints);
                let currentPoint = 0;
                let villagePointX = 0, villagePointZ = 0;
                for (let i = 0; i < LevelSize; i++) {
                    for (let j = 0; j < LevelSize; j++) {
                        if(villagelevelTemplate[i][j]>98) 
                            currentPoint++;
                        if(currentPoint == spawnPoint){
                            villagePointX = i;
                            villagePointZ = j;
                        }
                    }
                }
                
                HeightMap =  [];
                for (let i = 0; i < LevelSize; i++) {
                    HeightMap[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        if (villagelevelTemplate[i][j] >0){
                            HeightMap[i][j] = levelHeightTemplate[i][j] + 2;
                        }
                        else{
                            HeightMap[i][j] = levelHeightTemplate[i][j]+levelHeightNoise[i][j];
                        }
                    }
                }
                
                map =  [];
                for (let i = 0; i < LevelSize; i++) {
                    map[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        map[i][j] = []
                        for(let z = 0;z < 100; z++){
                            map[i][j][z] = Block.Air;
                        }
                    }
                }
                for(let i = 0; i < LevelSize; i++){
                    for(let j = 0; j < LevelSize; j++){
                        for(let z = 0; z < HeightMap[i][j]; z++){
                            map[i][j][z] = Block.Dirt;
                        }
                        map[i][j][HeightMap[i][j]]=Block.Grass; 
                    }
                }

                entities =  [];
                for (let i = 0; i < LevelSize; i++) {
                    entities[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        entities[i][j] = []
                        for(let z = 0;z < 100; z++){
                            entities[i][j][z] = Entity.Empty;
                        }
                    }
                }
                for (let i = 0; i< LevelSize; i++){
                    for (let j = 0; j< LevelSize; j++){
                            if(Math.random() < 0.09 && HeightMap[i][j]==waterLevel-1){
                                entities[i][j][waterLevel] = Entity.UnderwaterGrass;
                                //alert(1);
                            }
                            if(Math.random() < 0.009 && HeightMap[i][j]<waterLevel){
                                entities[i][j][waterLevel] = Entity.Waterlily;
                            }
                            if(Math.random() < TreeDensity && HeightMap[i][j]>=waterLevel){
                                if (villagelevelTemplate[i][j]<40){
                                    entities[i][j][HeightMap[i][j]] = Math.random()>0.5?Entity.Tree:Entity.PineTree;
                                    TreesLeft++;
                                }
                            }
                    }
                }
                if (generateVillage){
                    let y_ = HeightMap[villagePointX][villagePointZ];
                    //map[villagePointX][villagePointZ][y_]=Block.Dirt;
                    let j_ = villagePointZ;
                    for(let i = villagePointX-villageRadius; i < villagePointX+villageRadius; i++){
                        if (map[i][j_][y_] == Block.Grass){
                            let offset_ = Math.round((Math.random() - 0.5)*1.29);
                            map[i][j_][y_] = Block.Road;
                            j_+=offset_;
                            map[i][j_][y_] = Block.Road;
                        }
                    }
                    let i_ = villagePointX;
                    for(let j = villagePointZ-villageRadius; j < villagePointZ+villageRadius; j++){
                        if (map[i_][j][y_] == Block.Grass){
                            let offset_ = Math.round((Math.random() - 0.5)*1.29);
                            map[i_][j][y_] = Block.Road;
                            i_ += offset_;
                            map[i_][j][y_] = Block.Road;
                        }
                    }
                    function checkRadius(array,i,j,y,rad,object_){
                        for (let ii = i - rad; ii<= i+rad; ii++){
                            for (let jj = j - rad; jj<= j+rad; jj++){
                                    if (array[ii][jj][y]!==object_){
                                        return false;
                                    }
                                }
                            }
                        return true;
                    }
                    let housesNum = getRandomInt(housesRange[0],housesRange[1]);
                    for(let k = 0; k<housesNum;){
                        i_ = getRandomInt(villagePointX-villageRadius,villagePointX+villageRadius);
                        j_ = getRandomInt(villagePointZ-villageRadius,villagePointZ+villageRadius);
                        if(checkRadius(map,i_,j_,y_,2,Block.Grass)&&checkRadius(entities,i_,j_,y_,2,Entity.Empty)){
                            for (let ii = i_ - 2; ii<= i_+2; ii++){
                                for (let jj = j_ - 2; jj<= j_+2; jj++){
                                    entities[ii][jj][y_] = Entity.NotPlaceable; 
                                }
                            }
                            entities[i_][j_][y_] = Entity.House;
                            k++;
                            let way = [0,0];
                            let steps = 0;
                            for(let step = 0; step<villageRadius; step++){
                                if(map[i_-step][j_][y_]==Block.Road){
                                    way[0] = -1;
                                    break;
                                }
                                if(map[i_+step][j_][y_]==Block.Road){
                                    way[0] = 1;
                                    break;
                                }
                                if(map[i_][j_-step][y_]==Block.Road){
                                    way[1] = -1;
                                    break;
                                }
                                if(map[i_][j_+step][y_]==Block.Road){
                                    way[1] = 1;
                                    break;
                                }
                                steps = step;
                            }
                            VillageHouses.push({x: i_,z: j_, y: y_});
                            for (let step = 0; step<steps+2; step++){
                                map[i_+way[0]*step][j_+way[1]*step][y_] = Block.Road;
                                let offset_ = Math.round((Math.random() - 0.5)*1.30);
                                if(!way[0])
                                    i_ += offset_;
                                if(!way[1])
                                    j_ += offset_;
                                map[i_+way[0]*step][j_+way[1]*step][y_] = Block.Road;
                            }
                        }
                    }
                    for(let k = 0; k<VillageHouses.length; k++){
                        let x_ = VillageHouses[k].x;
                        let z_ = VillageHouses[k].z;
                        let y_ = VillageHouses[k].y;
                        for (let ii = x_ - 2; ii<= x_+2; ii++){
                            for (let jj = z_ - 2; jj<= z_+2; jj++){
                                entities[ii][jj][y_] = Entity.Empty; 
                            }
                        }
                        if(map[x_-1][z_][y_] == Block.Road){
                            VillageHouses[k].Way = [-1,0]; 
                            for (let ii = x_; ii<= x_+2; ii++){
                                for (let jj = z_ - 1; jj<= z_+1; jj++){
                                    entities[ii][jj][y_] = Entity.NotPlaceable; 
                                }
                            }
                        }
                        else if(map[x_+1][z_][y_] == Block.Road){
                            VillageHouses[k].Way = [1,0];
                            for (let ii = x_-2; ii<= x_; ii++){
                                for (let jj = z_ - 1; jj<= z_+1; jj++){
                                    entities[ii][jj][y_] = Entity.NotPlaceable; 
                                }
                            }
                        }
                        else if(map[x_][z_-1][y_] == Block.Road){
                            VillageHouses[k].Way = [0,-1]; 
                            for (let ii = x_-1; ii<= x_+1; ii++){
                                for (let jj = z_; jj<= z_+2; jj++){
                                    entities[ii][jj][y_] = Entity.NotPlaceable; 
                                }
                            }
                        }
                        else if(map[x_][z_+1][y_] == Block.Road){
                            VillageHouses[k].Way = [0,1]; 
                            for (let ii = x_-1; ii<= x_+1; ii++){
                                for (let jj = z_-2; jj<= z_; jj++){
                                    entities[ii][jj][y_] = Entity.NotPlaceable; 
                                }
                            }
                        }
                        /*entities[x_][z_][y_] = Entity.House; 
                        entities[x_+2][z_][y_+1] = Entity.VerticalFence;
                        entities[x_+2][z_-1][y_+1] = Entity.VerticalFence; 
                        entities[x_+2][z_+1][y_+1] = Entity.VerticalFence; 
                         
                        entities[x_-2][z_][y_+1] = Entity.VerticalFence;
                        entities[x_-2][z_-1][y_+1] = Entity.VerticalFence; 
                        entities[x_-2][z_+1][y_+1] = Entity.VerticalFence; */
                    }   
                }
                /*walls =  [];
                for (let i = 0; i < LevelSize; i++) {
                    walls[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        walls[i][j] = []
                        for(let z = 0;z < 100; z++){
                            walls[i][j][z] = false;
                        }
                    }
                }*/

                let Center=LevelSize/2;
                MainHero.position.set(Center,HeightMap[Center][Center]+1,Center);
                camera.position.set(MainHero.position.x ,MainHero.position.y,MainHero.position.z);
                camera.position.add(cameraoffset);
                directionalLight.position.set(camera.position.x + 20,camera.position.y + 10,camera.position.z - 20);
                directionalLight.target.position.set(directionalLight.position.x-30,directionalLight.position.y-20,directionalLight.position.z+20);

                loadMeshes();
                 Center=LevelSize/2;
                
                async function initScene(){
                    /*Camera*/
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color( 0x338BA8 );
                    

                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);//100
                    camera.position.x = 20.6+40;
                    camera.position.y = 20;
                    camera.position.z = 30+40;



                    camera.rotation.x = -Math.PI/4-0.15; //camera.rotation.x = -Math.PI/2 + 0.3;
                    /*Rendering*/
                    renderer = new THREE.WebGLRenderer({antialias:true});
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    renderer.shadowMap.enabled = true;
                    document.body.appendChild(renderer.domElement);
                    composer = new EffectComposer(renderer);
                    composer.addPass(new RenderPass(scene, camera));
                    let bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                    bloomPass.renderToScreen = true;
                    bloomPass.threshold = 0;
                    bloomPass.strength = 0.2;
                    bloomPass.radius = 0;
                    composer.addPass(bloomPass);
                    /*Materials*/
                    blocksTexture = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/texture.png');
                    blocksTexture.minFilter = THREE.NearestFilter;
                    blocksTexture.magFilter = THREE.NearestFilter;
                    blocksMaterial = new THREE.MeshLambertMaterial({map: blocksTexture/*, wireframe:true, color: 0xAAAAAAA*/});
                    
                    modelsTexture = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/texture_models.png');
                    modelsTexture.minFilter = THREE.NearestFilter;
                    modelsTexture.magFilter = THREE.NearestFilter;
                    modelsMaterial = new THREE.MeshLambertMaterial({map: modelsTexture/**/});
                    //modelsMaterial.side = THREE.DoubleSide;
                    
                    waterTexture1 = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/water1.png');
                    waterTexture1.wrapS = THREE.RepeatWrapping;
                    waterTexture1.wrapT = THREE.RepeatWrapping;
                    waterTexture1.repeat.x = LevelSize/2;
                    waterTexture1.repeat.y = LevelSize/2;
                    waterTexture1.minFilter = THREE.NearestFilter;
                    waterTexture1.magFilter = THREE.NearestFilter;
                    waterMaterial1 = new THREE.MeshBasicMaterial({map: waterTexture1, transparent: true, opacity: 0.50});
                    
                    waterTexture2 = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/water2.png');
                    waterTexture2.wrapS = THREE.RepeatWrapping;
                    waterTexture2.wrapT = THREE.RepeatWrapping;
                    waterTexture2.repeat.x = LevelSize/2;
                    waterTexture2.repeat.y = LevelSize/2;
                    waterTexture2.minFilter = THREE.NearestFilter;
                    waterTexture2.magFilter = THREE.NearestFilter;
                    waterMaterial2 = new THREE.MeshBasicMaterial({map: waterTexture2, transparent: true, opacity: 0.55, color: 0xffffff});
                    
                    borderTexture = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/clouds.png');
                    borderTexture.minFilter = THREE.NearestFilter;
                    borderTexture.magFilter = THREE.NearestFilter;
                    borderMaterial = new THREE.MeshBasicMaterial({map: borderTexture, transparent: true, opacity: 0.50});
                    //borderMaterial.side = THREE.DoubleSide;
                    /*Models*/
                    for(let i = 1; i<=3; i++){
                        let house = await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/House'+i+'.obj', modelsMaterial);
                        house.scale.x = 0.5;
                        house.scale.y = 0.5;
                        house.scale.z = 0.5;
                        HouseModels.push(house);
                    }
                    FenceModel = await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/fence.obj', modelsMaterial);
                    FenceModel.scale.set(0.5,0.5,0.5);
                    UnderwaterGrassModel = await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/underwatergrass.obj', modelsMaterial);
                    UnderwaterGrassModel.scale.set(0.5,0.5,0.5);
                    WaterlilyModel =  await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/waterlily.obj', modelsMaterial);
                    WaterlilyModel.scale.set(0.5,0.5,0.5);
                    TreeModel =  await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/tree1.obj', modelsMaterial);
                    PineTreeModel =  await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/tree2.obj', modelsMaterial);
                    LogModel =  await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/log.obj', modelsMaterial);
                    BridgeModel =  await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/bridge.obj', modelsMaterial);
                    MainHero = await LoadObjModel('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/models/beaver.obj', modelsMaterial);
                    MainHero.scale.set(0.5,0.5,0.5);
                    MainHero.receiveShadow = true;
                    MainHero.castShadow = true;


                    /*Lighting*/
                    const color = 0xFFFFFF;
                    const intensity = 0.55;
                    ambientLight = new THREE.AmbientLight(color, intensity);
                    scene.add(ambientLight);
                    directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.x = camera.position.x + 10;
                    directionalLight.position.y = camera.position.y + 10;;
                    directionalLight.position.z = camera.position.z - 30;;
                    
                    directionalLight.castShadow = true;
                    directionalLight.shadow.mapSize.width = 1024*1; 
                    directionalLight.shadow.mapSize.height = 1024*1; 
                    directionalLight.shadow.camera.near = 0.5; 
                    directionalLight.shadow.camera.far = 128; 
                    let lightradius = 25; //60
                    directionalLight.shadow.camera.right = lightradius; 
                    directionalLight.shadow.camera.top = lightradius; 
                    directionalLight.shadow.camera.bottom = -lightradius;
                    directionalLight.shadow.camera.left = -lightradius;
                    directionalLight.target = new THREE.Object3D();
                    
                    scene.add(directionalLight.target);
                    scene.add(directionalLight);
                    directionalLight.position.x += 10;
                    directionalLight.target.position.x += 40;
                    directionalLight.target.position.z += 60;

                    directionalLight.position.z += 20;


                }
                function loadMeshes(){

                    scene.add(MainHero);
                    let planegeometry = new THREE.PlaneGeometry(); 
                    let meshesArray = [];
                    let uvAttribute = planegeometry.getAttribute("uv");
                    let uvArray = uvAttribute.array;
                    //uvAttribute.needsUpdate = true;
                    
                    let testgrassmat = new THREE.MeshStandardMaterial({color: 0x009900, wireframe: true}); 
                    let testdirtmat = new THREE.MeshStandardMaterial({color: 0x964B00, wireframe: true}); 
                    let testwhitemat = new THREE.MeshStandardMaterial({color: 0xAAAAAA, wireframe: false}); 

                    //helper function that setting uv for side planes of block
                    function pickSideUV(i,j,z,geometry){
                        const uvAttribute = geometry.getAttribute("uv");
                        const uvArray = uvAttribute.array;      
                        switch (map[i][j][z]){
                            case Block.Grass:
                                setUVcoordinates(0,7,uvArray);
                                break;
                            case Block.Dirt:
                                setUVcoordinates(1,7,uvArray);
                                if (Math.random() < stonecoef) setUVcoordinates(2,7,uvArray);
                            break;
                        }
                    }
                    let stonecoef = 0.10;
                    for (let i = 0; i < LevelSize; i++) {
                        for (let j = 0; j < LevelSize; j++) {
                            for (let z = 0; z < 100; z++){
                                //blocks
                                if(map[i][j][z]==undefined || map[i][j][z]==Block.Air){continue}
                                if(map[i][j][z+1]==Block.Air || map[i][j][z+1]==undefined){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateX(-Math.PI/2);
                                    planegeometry.translate(i,z+0.5,j);  
                                    const uvAttribute = planegeometry.getAttribute("uv");
                                    const uvArray = uvAttribute.array;  
                                    let offset;

                                    switch (map[i][j][z]){
                                        case Block.Grass:
                                            offset = Math.random()>0.5?0:getRandomInt(1,4);
                                            setUVcoordinates(4+(z<waterLevel?0:offset),6,uvArray);
                                            break;
                                        case Block.Road:
                                            if(map[i][j+1][z]==Block.Road&&map[i][j-1][z]==Block.Road && map[i+1][j][z]==Block.Road&&map[i-1][j][z]==Block.Road) 
                                            {
                                                setUVcoordinates(2,5,uvArray);break;//down && up && right && left 
                                            }
                                            if(map[i][j-1][z]==Block.Road && map[i+1][j][z]==Block.Road&&map[i-1][j][z]==Block.Road) 
                                            {
                                                setUVcoordinates(5,4,uvArray);break;// up && right && left 
                                            }
                                            if(map[i][j+1][z]==Block.Road&& map[i+1][j][z]==Block.Road&&map[i-1][j][z]==Block.Road) 
                                            {
                                                setUVcoordinates(4,4,uvArray);break;//down && right && left 
                                            }
                                            if(map[i][j+1][z]==Block.Road&&map[i][j-1][z]==Block.Road &&map[i-1][j][z]==Block.Road) 
                                            {
                                                setUVcoordinates(6,4,uvArray);break;//down && up && left 
                                            }
                                            if(map[i][j+1][z]==Block.Road&&map[i][j-1][z]==Block.Road && map[i+1][j][z]==Block.Road) 
                                            {
                                                setUVcoordinates(7,4,uvArray);break;//down && up && right 
                                            }
                                            if(map[i][j+1][z]==Block.Road&&map[i+1][j][z]==Block.Road){ //down && right
                                                setUVcoordinates(2,4,uvArray);break;
                                            }
                                            if(map[i][j+1][z]==Block.Road&&map[i-1][j][z]==Block.Road){ //down && left 
                                                setUVcoordinates(3,4,uvArray);break;
                                            }
                                            if(map[i][j-1][z]==Block.Road&&map[i+1][j][z]==Block.Road){ //up && right
                                                setUVcoordinates(0,4,uvArray);break;
                                            }
                                            if(map[i][j-1][z]==Block.Road&&map[i-1][j][z]==Block.Road){ //up && left 
                                                setUVcoordinates(1,4,uvArray);break;
                                            }
                                            
                                            if(map[i][j+1][z]==Block.Road&&map[i][j-1][z]==Block.Road) //down && up 
                                            {
                                                setUVcoordinates(0,5,uvArray);break;
                                            }
                                            if(map[i+1][j][z]==Block.Road&&map[i-1][j][z]==Block.Road) //right && left 
                                            {
                                                setUVcoordinates(1,5,uvArray);break;
                                            }
                                            if(map[i][j+1][z]==Block.Road){ //down
                                                setUVcoordinates(6,5,uvArray);break;
                                            }
                                            if(map[i][j-1][z]==Block.Road){ //up
                                                setUVcoordinates(4,5,uvArray);break;
                                            }
                                            if(map[i+1][j][z]==Block.Road){ //right
                                                setUVcoordinates(5,5,uvArray);break;
                                            }
                                            if(map[i-1][j][z]==Block.Road){ //left
                                                setUVcoordinates(7,5,uvArray);break;
                                            }
                                            
                                            setUVcoordinates(3,5,uvArray);
                                            break;
                                    }
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i][j+1]==undefined || map[i][j+1][z]==Block.Air){ //смотрит в камеру по дефолту
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(0);
                                    planegeometry.translate(i,z,j+0.5);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i][j-1]==undefined || map[i][j-1][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(Math.PI);
                                    planegeometry.translate(i,z,j-0.5);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i+1]==undefined || map[i+1][j][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(Math.PI/2);
                                    planegeometry.translate(i+0.5,z,j);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i-1]==undefined || map[i-1][j][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(-Math.PI/2);
                                    planegeometry.translate(i-0.5,z,j);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                
                            }
                        }
                    }
                    for (let i = 0; i < LevelSize; i++) {
                        for (let j = 0; j < LevelSize; j++) {
                            for (let z = 0; z < 100; z++){
                                //entities
                                let block;
                                switch(entities[i][j][z]){
                                    case Entity.House:
                                        let house = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshBasicMaterial({color: 0xAA0000}));
                                        //scene.add(house);
                                        house.position.x = i;
                                        house.position.y = z+1.3;
                                        house.position.z = j;
                                        break;
                                    case Entity.NotPlaceable:
                                        block = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshBasicMaterial({color: 0x0000AA,transparent:true, opacity: 0.3}));
                                        //scene.add(block);
                                        block.position.x = i;
                                        block.position.y = z+1;
                                        block.position.z = j;
                                        break;
                                    case Entity.VerticalFence:
                                        block = FenceModel.clone();
                                        scene.add(block);
                                        block.rotation.y = Math.PI/2;
                                        block.position.x = i;
                                        block.position.y = z;
                                        block.position.z = j;
                                        block = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshBasicMaterial({color: 0x0000AA,transparent:true, opacity: 0.3}));
                                        scene.add(block);
                                        block.position.x = i;
                                        block.position.y = z+1;
                                        block.position.z = j;
                                        break;
                                    case Entity.UnderwaterGrass:
                                        block = UnderwaterGrassModel.clone();
                                        scene.add(block);
                                        block.position.x = i;
                                        block.position.y = z + 0.5;
                                        block.position.z = j;
                                        break;
                                    case Entity.Waterlily:
                                        block = WaterlilyModel.clone();
                                        scene.add(block);
                                        block.position.x = i;
                                        block.position.y = z+0.5;
                                        block.position.z = j;
                                        block.rotation.y = Math.PI/2 *getRandomInt(0,4);
                                        break;
                                    case Entity.Tree:
                                        block = TreeModel.clone();
                                        scene.add(block);
                                        block.position.x = i;
                                        block.position.y = z+1;
                                        block.position.z = j;
                                        block.scale.set(1.6,1.6,1.6);
                                        block.rotation.y = Math.PI/2 *getRandomInt(0,4);
                                        ModelsIngame[i][j][z]=block;

                                        break;
                                    case Entity.PineTree:
                                        block = PineTreeModel.clone();
                                        scene.add(block);
                                        block.position.x = i;
                                        block.position.y = z+1;
                                        block.position.z = j;
                                        block.scale.set(1.6,1.6,1.6);
                                        block.rotation.y = Math.PI/2 *getRandomInt(0,4);
                                        ModelsIngame[i][j][z]=block;
                                        break;
                                }
                            }
                        }
                    }
                    for(let k = 0; k<VillageHouses.length;k++){
                        let HouseMesh = HouseModels[getRandomInt(0,3)].clone();
                        let x_ = VillageHouses[k].x;
                        let z_ = VillageHouses[k].z;
                        let y_ = VillageHouses[k].y+0.5;
                        HouseMesh.position.x = x_;
                        HouseMesh.position.z = z_;
                        HouseMesh.position.y = y_;
                        if(VillageHouses[k].Way[0]==0){
                            if(VillageHouses[k].Way[1]==-1)HouseMesh.rotation.y = -Math.PI/2;
                            if(VillageHouses[k].Way[1]==1)HouseMesh.rotation.y = Math.PI/2;
                        }
                        else{
                            if(VillageHouses[k].Way[0]==-1)HouseMesh.rotation.y = 0;
                            if(VillageHouses[k].Way[0]==1)HouseMesh.rotation.y = Math.PI; 
                        }
                        scene.add(HouseMesh);
                    }
                    /*let villagepoint = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshBasicMaterial({color: 0xAA0000}));
                    villagepoint.position.y = HeightMap[villageSpawnPointX][villageSpawnPointZ];
                    villagepoint.position.x = villageSpawnPointX;
                    villagepoint.position.z = villageSpawnPointZ;
                    scene.add(villagepoint);*/
                    
                    let landscapemodel = BufferGeometryUtils.mergeBufferGeometries(meshesArray);
                    let landscapeMesh = new THREE.Mesh(landscapemodel, blocksMaterial);
                    landscapeMesh.receiveShadow = true;
                    landscapeMesh.castShadow = true;
                    scene.add(landscapeMesh);
                    //console.info(new Blob([JSON.stringify(map)]).size);

                    
                    let waterGeometry1 = new THREE.PlaneGeometry();
                    waterGeometry1.scale(LevelSize,LevelSize,LevelSize);
                    waterGeometry1.rotateX(-Math.PI/2);
                   

                    let waterGeometry2 = new THREE.PlaneGeometry();
                    waterGeometry2.scale(LevelSize,LevelSize,LevelSize);
                    waterGeometry2.rotateX(-Math.PI/2);
                    

                    waterMesh1 = new THREE.Mesh(waterGeometry1,waterMaterial1);
                    waterMesh2 = new THREE.Mesh(waterGeometry2,waterMaterial2);
                    waterMesh1.position.set(LevelSize/2-0.5,0,LevelSize/2-0.5);
                    waterMesh2.position.set(LevelSize/2-0.5,0,LevelSize/2-0.5);

                    waterMesh1.position.y = waterLevel+0.3;
                    waterMesh2.position.y = waterLevel-1+0.3;
                    waterMesh1.receiveShadow = true;
                    waterMesh1.castShadow = true;
                    waterMesh2.receiveShadow = true;
                    waterMesh2.castShadow = true;
                    scene.add(waterMesh1);
                    scene.add(waterMesh2);

                    let waterfallGeometries = [[],[],[],[]];

                    for (let i = 0; i < LevelSize; i++) {
                        if(map[i][LevelSize-1][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(0);
                                planegeometry.translate(i,0.3-0.5,LevelSize-0.499);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                            }
                        }
                        if(map[i][0][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(Math.PI);
                                planegeometry.translate(i,0.3-0.5,-0.501);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                                
                            }
                        }
                    }
                    for (let j = 0; j < LevelSize; j++) {
                        if(map[LevelSize-1][j][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(Math.PI/2);
                                planegeometry.translate(LevelSize-0.499,0.3-0.5,j);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                            }
                        }
                        if(map[0][j][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(-Math.PI/2);
                                planegeometry.translate(-0.501,0.3-0.5,j);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                                
                            }
                        }
                    }

                    for (let z = 0; z<4; z++){
                        if(waterfallGeometries[z].length>0){
                            waterfallLayers[z] = new THREE.Mesh(BufferGeometryUtils.mergeBufferGeometries(waterfallGeometries[z]),borderMaterial);
                            waterfallLayers[z].position.y = waterLevel-z;
                            scene.add(waterfallLayers[z]);
                        }
                    }
                    if(!isWaterAnimated)
                    {
                        animateWater();
                    }
                    animateWaterFall();
                    let cloudsGeometries = [];
                    for(let c = 0; c<cloudsAmount; c++){
                        let planegeometry = new THREE.PlaneGeometry(); 
                        let radius = 11;
                        let offsetx = getRandomFloat(-radius,LevelSize+radius);
                        let offsetz = getRandomFloat(-radius,LevelSize+radius);
                        if(Math.random()>0.5){
                            while(offsetx>-1&&offsetx<LevelSize+1){
                                offsetx = getRandomFloat(-radius,LevelSize+radius);
                            }
                        }
                        else{
                            while(offsetz>-1&&offsetz<LevelSize+1){
                                offsetz = getRandomFloat(-radius,LevelSize+radius);
                            }
                        }
                        let cloudType = getRandomInt(0,6);
                        let uvAttribute = planegeometry.getAttribute("uv");
                        let uvArray = uvAttribute.array;
                        planegeometry.scale(2,2,2);
                        switch(cloudType){
                            case 0:
                            uvArray[0] = 0;            uvArray[1] = 1; //1 
                            uvArray[2] = 0.375;        uvArray[3] = 1;//2 
                            uvArray[4] = 0;            uvArray[5] = 0.75;//3 
                            uvArray[6] = 0.375;        uvArray[7] = 0.75;// 4
                            planegeometry.scale(1.5,1,1)
                            break;
                            case 1:
                            uvArray[0] = 0;            uvArray[1] = 0.75; //1 
                            uvArray[2] = 0.375;        uvArray[3] = 0.75;//2 
                            uvArray[4] = 0;            uvArray[5] = 0.5;//3 
                            uvArray[6] = 0.375;        uvArray[7] = 0.5;// 4
                            planegeometry.scale(1.5,1,1)
                            break;
                            case 2:
                            uvArray[0] = 0.375;            uvArray[1] = 1; //1 
                            uvArray[2] = 0.375+0.25;        uvArray[3] = 1;//2 
                            uvArray[4] = 0.375;            uvArray[5] = 0.75;//3 
                            uvArray[6] = 0.375+0.25;        uvArray[7] = 0.75;// 4
                            break;
                            case 3:
                            uvArray[0] = 0.375;         uvArray[1] = 0.75; //1 
                            uvArray[2] = 0.375+0.25;        uvArray[3] = 0.75;//2 
                            uvArray[4] = 0.375;           uvArray[5] = 0.5;//3 
                            uvArray[6] = 0.375+0.25;        uvArray[7] = 0.5;// 4
                            break;
                            case 4:
                            uvArray[0] = 0.625;            uvArray[1] = 1; //1 
                            uvArray[2] = 1;        uvArray[3] = 1;//2 
                            uvArray[4] = 0.625;            uvArray[5] = 0.75;//3 
                            uvArray[6] = 1;        uvArray[7] = 0.75;// 4
                            planegeometry.scale(1.5,1,1)
                            break;
                            case 5:
                            uvArray[0] = 0.625;            uvArray[1] = 0.75; //1 
                            uvArray[2] = 1;        uvArray[3] = 0.75;//2 
                            uvArray[4] = 0.625;            uvArray[5] = 0.5;//3 
                            uvArray[6] = 1;        uvArray[7] = 0.5;// 4
                            planegeometry.scale(1.5,1,1)
                            break;
                        }
                        //planegeometry.translate(-5,0,-5);
                        planegeometry.rotateX(-Math.PI/3.5);
                        planegeometry.translate(offsetx,(c)/cloudsAmount*10-5,offsetz);

                       // 
                       // setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                        cloudsGeometries.push(planegeometry);
                    }
                    clouds[0] = new THREE.Mesh(BufferGeometryUtils.mergeBufferGeometries(cloudsGeometries),borderMaterial);
                    clouds[0].position.y = 0;;
                    scene.add(clouds[0]);
                }

                function MapRange(array,layersNumber,maxNumber = 255){
                    let coefficient = layersNumber/maxNumber;
                    let newarray = [];
                    for (let i = 0; i < array.length; i++) {
                        newarray[i] = [];
                        for (let j = 0; j < array[i].length; j++) {
                            newarray[i][j] = Math.round(array[i][j]*coefficient);
                        }
                    }
                    return newarray;
                }

                //channel r - 0   g - 1   b - 2  a  - 3
                async function LoadImageToArray(url,channel=0){
                    let array = []
                    let promise = new Promise(function(resolve, reject) {
                        imageLoader.load(url,
                        function ( image ) {
                            const canvas = document.createElement('canvas');
                            canvas.width = image.width;
                            canvas.height = image.height; 
                            const context = canvas.getContext('2d',{willReadFrequently: true});
                            context.drawImage( image, 0, 0 );
                            for (let i = 0; i < image.height; i++) {
                                array[i] = [];
                                for (let j = 0; j < image.width; j++) {
                                    array[i][j] = context.getImageData(i, j, 1, 1).data[channel];
                                }
                            }
                            resolve();
                        },undefined,function () {console.error( 'An error happened.' );});
                    });
                    await promise;
                    return array;
                }

                async function LoadObjModel(url,Material,castShadow_ = true,receiveShadow_ = true ){
                    let mesh;
                    let promise = new Promise(function(resolve, reject) {
                        objLoader.load(url,
                        function ( model ) {
                            mesh=model;
                            resolve();
                        },undefined,function () {console.error( 'An error happened.' );});
                    });
                    await promise;
                    if (Material){
                        mesh.traverse(child => {
                        if (child.material) 
                            child.material = Material;
                        if (child.isMesh){
                            child.castShadow = castShadow_;
                            child.receiveShadow = receiveShadow_;
                        }
                        });
                    }
                    return mesh;
                }
            }

            var plane;
            var xSpeed = 0.6;
            var ySpeed = 0.6;
            var zSpeed = 0.6;
            document.addEventListener("keydown", onDocumentKeyDown, false);

            let isMoving = false;
            let isSwimming = false;
            let nextIsBridge = false;
            async function HeroMove(Direction){

                if(isMoving)return;

                isMoving = true;
                if (Direction.x == 1) MainHero.rotation.y = (Math.PI/2)*0;
                if (Direction.x == -1)MainHero.rotation.y = (Math.PI/2)*2;
                if (Direction.z == 1)MainHero.rotation.y = (Math.PI/2)*3;
                if (Direction.z == -1)MainHero.rotation.y = (Math.PI/2)*1;

                let destination = new THREE.Vector3(MainHero.position.x,MainHero.position.y,MainHero.position.z);
                destination.add(Direction);
                if(destination.x<0||destination.x>LevelSize-1)
                {
                    isMoving = false;
                    return;
                }
                if(destination.z<0||destination.z>LevelSize-1) 
                {
                    isMoving = false;
                    return;
                }
                destination.y = HeightMap[destination.x][destination.z]+1;


                if(destination.y<=waterLevel)
                {
                    destination.y = waterLevel;
                    isSwimming = true;
                }
                else{
                    isSwimming = false;
                }

                let jumpheight = destination.y - MainHero.position.y; 
                if(Math.abs(jumpheight)>1){
                    isMoving = false;
                    return;
                }
                let targetEntity = entities[destination.x][destination.z][destination.y-1];
                if(targetEntity==Entity.NotPlaceable){
                    isMoving = false;
                    return;
                }
                if(targetEntity==Entity.Tree || targetEntity==Entity.PineTree){
                    let targetModel = ModelsIngame[destination.x][destination.z][destination.y-1];
                    let t = 0;
                    while(t<10){
                        let value = Math.sin(0.5*(t*t)+9)*Math.sqrt((t*-1)+10); // Math.sin(​0.5*(​t*t)+​9)//*Math.​sqrt(​(t*-1)+​10);
                        targetModel.position.x = destination.x + value*0.04;
                        t += 0.15;
                        await delay(1);
                    }
                    if(Math.random()<0.65){
                        entities[destination.x][destination.z][destination.y-1] = Entity.Empty;
                        scene.remove(targetModel);
                        
                        let block = LogModel.clone();
                        scene.add(block);
                        block.position.x = destination.x;
                        block.position.y = destination.y-0.35;
                        block.position.z = destination.z;
                        //block.scale.set(1.6,1.6,1.6);
                        block.rotation.y = Math.PI/2 *getRandomInt(0,4);
                        ModelsIngame[destination.x][destination.z][destination.y-1]=block;
                        entities[destination.x][destination.z][destination.y-1]=Entity.Log;
                        TreesLeft -=1 ;
                        console.log("trees: " + TreesLeft);
                        UpdateGameInfo();
                    }
                    isMoving = false;
                    return;
                }
                if(targetEntity==Entity.Log){
                    setTimeout(()=>{
                        scene.remove(ModelsIngame[destination.x][destination.z][destination.y-1]);
                        ModelsIngame[destination.x][destination.z][destination.y-1]=undefined;
                        entities[destination.x][destination.z][destination.y-1]=Entity.Empty;
                        LogsInInv+=1;
                        UpdateGameInfo();
                        console.log("logs: " + LogsInInv);
                    },250)
                }

                if(nextIsBridge&&targetEntity==Entity.Empty){

                    let block = BridgeModel.clone();
                        scene.add(block);
                        block.position.x = destination.x;
                        block.position.y = destination.y;
                        block.position.z = destination.z;
                        //block.scale.set(1.6,1.6,1.6);
                        block.rotation.y = Math.PI/2 *getRandomInt(0,4);
                        ModelsIngame[destination.x][destination.z][destination.y-1]=block;
                        entities[destination.x][destination.z][destination.y-1]=Entity.Bridge;
                        nextIsBridge = false;
                        UpdateGameInfo();
                        HeightMap[destination.x][destination.z] = destination.y;
                    isMoving = false;
                    return;
                }

                let A = {x: MainHero.position.x, y: MainHero.position.y, z: MainHero.position.z} ;
                let B = {x: destination.x, y: destination.y, z: destination.z};
                
                let t = 0;
                let y_off = 0;
                while(t<1){
                    t +=0.02;
                    if(!isSwimming){
                        if(t<=0.5){y_off+=0.013}
                        else {y_off-=0.013}
                    }
                    let int_x = lerp(A.x,B.x,t);
                    let int_y = lerp(A.y,B.y,t);
                    let int_z = lerp(A.z,B.z,t);
                    MainHero.position.set(int_x,int_y+y_off,int_z);
                    let t_ = -(t-1)*(t-1)+1;
                    int_x = lerp(A.x,B.x,t_);
                    int_y = lerp(A.y,B.y,t_);
                    int_z = lerp(A.z,B.z,t_);
                    camera.position.set(int_x,int_y,int_z);
                    camera.position.add(cameraoffset);
                    await delay(1);
                }

                MainHero.position.set(destination.x,destination.y,destination.z);
                camera.position.set(MainHero.position.x,MainHero.position.y,MainHero.position.z);
                camera.position.add(cameraoffset);

                directionalLight.position.set(camera.position.x + 20,camera.position.y + 10,camera.position.z - 20);
                directionalLight.target.position.set(directionalLight.position.x-30,directionalLight.position.y-20,directionalLight.position.z+20);
                isMoving = false;

            }
            function lerp(a,b,t){
                return a * (1 - t) + b * t;
            }
            
            function UpdateGameInfo(){
                if(LogsInInv>=3){
                    handimage.style.background = `center / contain no-repeat url("interface/log_icon.png");`;
                }
                else{
                    handimage.style.background = ``;
                }
                GameInfo.innerHTML = `You need to chop down <span class="statsinfo">${TreesLeft}</span> more trees! <br> 
                You have <span class="statsinfo"> ${LogsInInv} </span>logs in inventory.`;
                if(TreesLeft<=0){
                    setTimeout(()=>
                    {GameInfo.innerHTML = `You`},1000)
                    setTimeout(()=>
                    {GameInfo.innerHTML = `You win!`},1500)
                    setTimeout(()=>
                    {GameInfo.innerHTML = `You win!!`},2600)
                    setTimeout(()=>
                    {GameInfo.innerHTML = `You win!!!`},3000)
                    setTimeout(()=>
                    {LevelManager('0')},4300)
                }
            }
            function onDocumentKeyDown(event) {
                var key = event.key;
                if (key == "E") {
                    camera.position.y += ySpeed;
                    directionalLight.position.y += ySpeed;
                    directionalLight.target.position.y += ySpeed;
                } else if (key == "Q") {
                    camera.position.y -= ySpeed;
                    directionalLight.position.y -= ySpeed;
                    directionalLight.target.position.y -= ySpeed;
                } else if (key == "A") {
                    camera.position.x -= xSpeed;
                    directionalLight.position.x -= xSpeed;
                    directionalLight.target.position.x -= xSpeed;
                } else if (key == "D") {
                    camera.position.x += xSpeed;
                    directionalLight.position.x += xSpeed;
                    directionalLight.target.position.x += xSpeed;
                } else if (key == "W") {
                    camera.position.z -= zSpeed;
                    directionalLight.position.z -= zSpeed;
                    directionalLight.target.position.z -= zSpeed;
                } else if (key == "S") {
                    camera.position.z += zSpeed;
                    directionalLight.position.z += zSpeed;
                    directionalLight.target.position.z += zSpeed;
                }
                if (key == "e") {
                    TryToBuild();
                } else if (key == "q") {

                } else if (key == "a") {
                    HeroMove(new THREE.Vector3(-1, 0, 0));
                } else if (key == "d") {
                    HeroMove(new THREE.Vector3(1, 0, 0));
                } else if (key == "w") {
                    HeroMove(new THREE.Vector3(0, 0,-1));
                } else if (key == "s") {
                    HeroMove(new THREE.Vector3(0,0, 1));
                } else if (key == " ") {

                }
                
            };


            function initLoaders(){
                textureLoader = new THREE.TextureLoader();
                objLoader = new OBJLoader();
                mtlLoader = new MTLLoader();
                imageLoader = new ImageLoader();
            }

            // The maximum is exclusive and the minimum is inclusive
            function getRandomInt(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min) + min); 
            }
            function getRandomFloat(min, max) {
                return Math.random() * (max - min) + min;
            }
            function createEnum(values) {
                const enumObject = {};
                for (const val of values) {
                    enumObject[val] = val;
                }
                return Object.freeze(enumObject);
            }
            //pass the uvAttribute.array here 
            function setUVcoordinates(xOffset,yOffset,uvarray){
                uvarray[0] = xOffset*uvOffset;            uvarray[1] = yOffset*(uvOffset)+uvOffset; //1 
                uvarray[2] = xOffset*(uvOffset)+uvOffset; uvarray[3] = yOffset*(uvOffset)+uvOffset;//2 
                uvarray[4] = xOffset*uvOffset;            uvarray[5] = yOffset*uvOffset;//3 
                uvarray[6] = xOffset*(uvOffset)+uvOffset; uvarray[7] = yOffset*uvOffset;// 4
            }

            //rotating constantly rotating water texture 90 degrees to make it look animated 
            async function animateWater(){
                isWaterAnimated=true;
                while(true){
                    waterMesh1.rotation.y += Math.PI/2;
                    waterMesh2.rotation.y += Math.PI/2;
                    await delay(400);
                }
            }
            async function animateWaterFall(){
                isWaterAnimated=true;
                while(true){
                    await delay(400);
                    for(let i = 0; i<4; i++){
                        waterfallLayers[i].position.y -= 1;
                        if(waterfallLayers[i].position.y < waterLevel-3)
                        {
                            waterfallLayers[i].position.y += 4;
                        }
                    }
                }
            }
            function animate() {
                requestAnimationFrame(animate);
                stats.begin();
                composer.render();
                stats.end();
            }
        </script>
    </body>

    </html>