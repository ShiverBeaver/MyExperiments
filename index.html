<DOCTYPE html>
    <html>

    <head>
        <meta charset="utf-8">
        <title>webgl test</title>
        <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three/build/three.module.js",
                    "three/": "https://unpkg.com/three@0.149.0/"
                }
            }
        </script>
    </head>

    <body>
        <script type="module">
            import * as THREE from 'three';
            import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js'
            import { TextureLoader } from "three/src/loaders/TextureLoader.js";
            import { ImageLoader } from "three/src/loaders/ImageLoader.js";
            import * as BufferGeometryUtils from "three/examples/jsm/utils/BufferGeometryUtils.js";
            import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
            import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
            let objLoader, textureLoader, mtlLoader, imageLoader;  
            let scene, camera, renderer, composer;
            let blocksTexture, modelsTexture, waterTexture; 
            let blocksMaterial, modelsMaterial, waterMaterial;
            let landscapeMesh; 
            let ambientLight, directionalLight;
            initLoaders();
            initScene();
            loadMeshes();
            
            animate();
            function initLoaders(){
                textureLoader = new THREE.TextureLoader();
                objLoader = new OBJLoader();
                mtlLoader = new MTLLoader();
                imageLoader = new ImageLoader();
            }
            function initScene(){
                 /*Camera*/
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.y = 3;
                camera.position.z = 5;
                camera.rotation.x = 50;
                 /*Rendering*/
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
                composer = new EffectComposer(renderer);
                composer.addPass(new RenderPass(scene, camera));
                let bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.renderToScreen = true;
                bloomPass.threshold = 0;
                bloomPass.strength = 0.2;
                bloomPass.radius = 0;
                composer.addPass(bloomPass);
                 /*Materials*/
                blocksTexture = textureLoader.load ('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/texture.png')
                blocksTexture.minFilter = THREE.NearestFilter;
                blocksTexture.magFilter = THREE.NearestFilter;
                blocksMaterial = new THREE.MeshStandardMaterial({map: blocksTexture});
                 /*Lighting*/
                const color = 0xFFFFFF;
                const intensity = 0.4;
                ambientLight = new THREE.AmbientLight(color, intensity);
                scene.add(ambientLight);
                directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.x = -1;
                directionalLight.position.y = 1;
                directionalLight.position.z = 1;
                directionalLight.castShadow = true;
                directionalLight.target = new THREE.Object3D();
                scene.add(directionalLight);
                
            }
            function loadMeshes(){
                let planegeometry = new THREE.PlaneGeometry(); 
                const uvAttribute = planegeometry.getAttribute("uv");
                const uvArray = uvAttribute.array;
                /*uvArray[0] = 0;uvArray[1] = 0.5;
                uvArray[2] = 0.5;uvArray[3] = 0.5;
                uvArray[4] = 0;uvArray[5] = 0;
                uvArray[6] = 0.5;uvArray[7] = 0;*/
                //uvAttribute.needsUpdate = true;
                let plane = new THREE.Mesh(planegeometry, blocksMaterial);
                scene.add(plane);
            }
            function animate() {
                requestAnimationFrame(animate);
                composer.render();
            };


            function MapRange(pixelArray,layersNumber,maxNumber = 255){
                return pixelArray.map(x => x.map(y => y.map()));
            }
            function LoadImageToArray(url){
                let array = []
                imageLoader.load(
                url,
                function ( image ) {
                    const canvas = document.createElement('canvas');
                    canvas.width = image.width;
                    canvas.height = image.height; 
                    document.body.appendChild(canvas);
                    const context = canvas.getContext('2d',{willReadFrequently: true});
                    context.drawImage( image, 0, 0 );
                    for (let i = 0; i < image.height; i++) {
                        array[i] = [];
                        for (let j = 0; j < image.width; j++) {
                            array[i][j] = context.getImageData(i, j, 1, 1);;
                        }
                    }
                },
                undefined,
                function () {console.error( 'An error happened.' );}
                );
                return array;
            }
    /* ************
            let geometry1 = new THREE.BoxGeometry();
            let geometry2 = new THREE.BoxGeometry();
            geometry1.scale(5,1,5)
            let mesh1 = new THREE.Mesh(geometry1, material1);
            geometry2.translate(0,1,0);
            let mesh2 = new THREE.Mesh(geometry2, material1);
            mesh2.position.y += 1;
            mesh2.receiveShadow = true;
            let twogeometries = BufferGeometryUtils.mergeBufferGeometries([geometry1,geometry2]);
            mesh2 = new THREE.Mesh(twogeometries,material1);
            mesh2.receiveShadow = true;
            mesh2.castShadow = true;
            scene.add(mesh2);           ********** */ 
        </script>
    </body>

    </html>