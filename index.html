<DOCTYPE html>
    <html>

    <head>
        <meta charset="utf-8">
        <title>webgl test</title>
        <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three/build/three.module.js",
                    "three/": "https://unpkg.com/three@0.149.0/"
                }
            }
        </script>
    </head>

    <body>
        <script type="module">
            import * as THREE from 'three';
            import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js'
            import { TextureLoader } from "three/src/loaders/TextureLoader.js";
            import { ImageLoader } from "three/src/loaders/ImageLoader.js";
            import * as BufferGeometryUtils from "three/examples/jsm/utils/BufferGeometryUtils.js";
            import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
            import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
            const delay = ms => new Promise(res => setTimeout(res, ms));
            
            let objLoader, textureLoader, mtlLoader, imageLoader;  
            let scene, camera, renderer, composer;
            let blocksTexture, modelsTexture, waterTexture1, waterTexture2; 
            let blocksMaterial, modelsMaterial, waterMaterial1, waterMaterial2;
            let currentLevel, landscapeMesh; 
            let LevelSize = 64;
            let uvOffset = 0.125;
            let ambientLight, directionalLight, lightTarget;
            function createEnum(values) {
                const enumObject = {};
                for (const val of values) {
                    enumObject[val] = val;
                }
                return Object.freeze(enumObject);
            }
            const Block = createEnum(['Air','Grass', 'Dirt']);
            currentLevel = 0;
            initLoaders();
            
            await loadLevel(1);



            animate();
            async function loadLevel(level){
                initScene();
                let noise = await LoadImageToArray('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/perlin_scale18_detail3.png');
                noise = MapRange(noise,getRandomInt(6,7));
                let maxOffset =  noise[0].length - LevelSize;
                let OffsetX = getRandomInt(0,maxOffset);
                let OffsetZ = getRandomInt(0,maxOffset);
                let levelHeightNoise =  [];
                for (let i = 0; i < LevelSize; i++) {
                    levelHeightNoise[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        levelHeightNoise[i][j] = noise[i+OffsetX][j+OffsetZ];
                    }
                }
                let template = await LoadImageToArray('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/testlevel.png');
                template = MapRange(template,getRandomInt(7,8));
                maxOffset =  template[0].length - LevelSize;
                OffsetX = getRandomInt(0,maxOffset);
                OffsetZ = getRandomInt(0,maxOffset);
                let levelHeightTemplate =  [];
                for (let i = 0; i < LevelSize; i++) {
                    levelHeightTemplate[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        levelHeightTemplate[i][j] = template[i+OffsetX][j+OffsetZ];
                    }
                }
                let HeightMap =  [];
                for (let i = 0; i < LevelSize; i++) {
                    HeightMap[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        HeightMap[i][j] = levelHeightTemplate[i][j]+levelHeightNoise[i][j];
                    }
                }
                
                let map =  [];
                for (let i = 0; i < LevelSize; i++) {
                    map[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        map[i][j] = []
                        for(let z = 0;z < 100; z++){
                            map[i][j][z] = Block.Air;
                        }
                    }
                }
                for(let i = 0; i < LevelSize; i++){
                    for(let j = 0; j < LevelSize; j++){
                        for(let z = 0; z < HeightMap[i][j]; z++){
                            map[i][j][z] = Block.Dirt;
                        }
                        map[i][j][HeightMap[i][j]]=Block.Grass; 
                    }
                }
                console.log(map);

                loadMeshes();
                function initScene(){
                    /*Camera*/
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
                    camera.position.y = 10;
                    camera.position.z = 20;
                    camera.position.x = 10.6;
                    camera.rotation.x = -Math.PI/4;
                    /*Rendering*/
                    renderer = new THREE.WebGLRenderer({antialias:true});
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.shadowMap.enabled = true;
                    document.body.appendChild(renderer.domElement);
                    composer = new EffectComposer(renderer);
                    composer.addPass(new RenderPass(scene, camera));
                    let bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                    bloomPass.renderToScreen = true;
                    bloomPass.threshold = 0;
                    bloomPass.strength = 0.2;
                    bloomPass.radius = 0;
                    composer.addPass(bloomPass);
                    /*Materials*/
                    blocksTexture = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/texture.png');
                    blocksTexture.minFilter = THREE.NearestFilter;
                    blocksTexture.magFilter = THREE.NearestFilter;
                    blocksMaterial = new THREE.MeshStandardMaterial({map: blocksTexture/*, wireframe:true, color: 0xAAAAAAA*/});
                    waterTexture1 = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/water1.png');
                    waterTexture2 = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/water2.png');
                    
                    waterTexture1.wrapS = THREE.RepeatWrapping;
                    waterTexture1.wrapT = THREE.RepeatWrapping;
                    waterTexture1.repeat.x = LevelSize/2;
                    waterTexture1.repeat.y = LevelSize/2;
                    waterTexture1.minFilter = THREE.NearestFilter;
                    waterTexture1.magFilter = THREE.NearestFilter;
                    waterMaterial1 = new THREE.MeshStandardMaterial({map: waterTexture1, transparent: true, opacity: 0.60});
                    
                    waterMaterial2 = new THREE.MeshStandardMaterial({map: waterTexture2});
                    
                    /*Lighting*/
                    const color = 0xFFFFFF;
                    const intensity = 0.2;
                    ambientLight = new THREE.AmbientLight(color, intensity);
                    scene.add(ambientLight);
                    directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                    directionalLight.position.x = 20;
                    directionalLight.position.y = 20;
                    directionalLight.position.z = -20;
                    
                    directionalLight.castShadow = true;
                    directionalLight.shadow.mapSize.width = 1024*2; 
                    directionalLight.shadow.mapSize.height = 1024*2; 
                    directionalLight.shadow.camera.near = 0.5; 
                    directionalLight.shadow.camera.far = 128; 
                    console.log(directionalLight.shadow.camera);
                    let lightradius = 30; 
                    directionalLight.shadow.camera.right = lightradius; 
                    directionalLight.shadow.camera.top = lightradius; 
                    directionalLight.shadow.camera.bottom = -lightradius;
                    directionalLight.shadow.camera.left = -lightradius;
                    directionalLight.target = new THREE.Object3D();
                    
                    scene.add(directionalLight.target);
                    scene.add(directionalLight);
                    directionalLight.position.x += 10;
                    directionalLight.target.position.x += 10;
                }
                function loadMeshes(){
                    let planegeometry = new THREE.PlaneGeometry(); 
                    let meshesArray = [];
                    let uvAttribute = planegeometry.getAttribute("uv");
                    let uvArray = uvAttribute.array;
                    //uvAttribute.needsUpdate = true;
                    plane = new THREE.Mesh(planegeometry, blocksMaterial);
                    plane.position.x = directionalLight.position.x;
                    plane.position.y = directionalLight.position.y;
                    plane.position.z = directionalLight.position.z;
                    scene.add(plane);
                    let testgrassmat = new THREE.MeshStandardMaterial({color: 0x009900, wireframe: true}); 
                    let testdirtmat = new THREE.MeshStandardMaterial({color: 0x964B00, wireframe: true}); 
                    let testwhitemat = new THREE.MeshStandardMaterial({color: 0xAAAAAA, wireframe: false}); 

                    function pickSideUV(i,j,z,geometry){
                        const uvAttribute = geometry.getAttribute("uv");
                        const uvArray = uvAttribute.array;      
                        switch (map[i][j][z]){
                            case Block.Grass:
                                setUVcoordinates(0,7,uvArray);
                                break;
                            case Block.Dirt:
                                setUVcoordinates(1,7,uvArray);
                                if (Math.random() < stonecoef) setUVcoordinates(2,7,uvArray);
                            break;
                        }
                    }
                    let stonecoef = 0.10;
                    for (let i = 0; i < LevelSize; i++) {
                        for (let j = 0; j < LevelSize; j++) {
                            for (let z = 0; z < 100; z++){
                                if(map[i][j][z]==undefined || map[i][j][z]==Block.Air){continue}
                                if(map[i][j][z+1]==Block.Air || map[i][j][z+1]==undefined){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateX(-Math.PI/2);
                                    planegeometry.translate(i,z+0.5,j);  
                                    const uvAttribute = planegeometry.getAttribute("uv");
                                    const uvArray = uvAttribute.array;      
                                    switch (map[i][j][z]){
                                        case Block.Grass:
                                            let offset = Math.random()>0.5?0:getRandomInt(1,4);
                                            setUVcoordinates(4+offset,6,uvArray);
                                            break;
                                    }
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i][j+1]==undefined || map[i][j+1][z]==Block.Air){ //смотрит в камеру
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(0);
                                    planegeometry.translate(i,z,j+0.5);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i][j-1]==undefined || map[i][j-1][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(Math.PI);
                                    planegeometry.translate(i,z,j-0.5);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i+1]==undefined || map[i+1][j][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(Math.PI/2);
                                    planegeometry.translate(i+0.5,z,j);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i-1]==undefined || map[i-1][j][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(-Math.PI/2);
                                    planegeometry.translate(i-0.5,z,j);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                            }
                        }
                    }
                    let landscapemodel = BufferGeometryUtils.mergeBufferGeometries(meshesArray);
                    let landscapeMesh = new THREE.Mesh(landscapemodel, blocksMaterial);
                    landscapeMesh.receiveShadow = true;
                    landscapeMesh.castShadow = true;
                    scene.add(landscapeMesh);
                    console.info(new Blob([JSON.stringify(map)]).size);

                    
                    let waterGeometry1 = new THREE.PlaneGeometry();
                    waterGeometry1.scale(LevelSize,LevelSize,LevelSize);
                    waterGeometry1.rotateX(-Math.PI/2);
                    waterGeometry1.translate(LevelSize/2,0,LevelSize/2);
                    waterGeometry1.translate(-0.5,0,-0.5);

                    let waterGeometry2 = new THREE.PlaneGeometry();
                    waterGeometry2.scale(LevelSize,LevelSize,LevelSize);
                    waterGeometry2.rotateX(-Math.PI/2);
                    waterGeometry2.translate(LevelSize/2,0,LevelSize/2);

                    uvAttribute = waterGeometry2.getAttribute("uv");
                    uvArray = uvAttribute.array;
                    uvArray[0] = 0;uvArray[1] = LevelSize/2;
                    uvArray[2] = LevelSize/2;uvArray[3] = LevelSize/2;
                    uvArray[4] = 0;uvArray[5] = 0;
                    uvArray[6] = LevelSize/2;uvArray[7] = 0;

                    let waterMesh1 = new THREE.Mesh(waterGeometry1,waterMaterial1);
                    let waterMesh2 = new THREE.Mesh(waterGeometry2,waterMaterial2);
                    waterMesh1.position.y = 4.3;
                    scene.add(waterMesh1);
                    //scene.add(waterMesh2);
                }
                function MapRange(array,layersNumber,maxNumber = 255){
                    let coefficient = layersNumber/maxNumber;
                    let newarray = [];
                    for (let i = 0; i < array.length; i++) {
                        newarray[i] = [];
                        for (let j = 0; j < array[i].length; j++) {
                            newarray[i][j] = Math.round(array[i][j]*coefficient);
                        }
                    }
                    return newarray;
                }
                //channel r - 0   g - 1   b - 2  a  - 3
                async function LoadImageToArray(url,channel=0){
                    let array = []
                    let promise = new Promise(function(resolve, reject) {
                        imageLoader.load(url,
                        function ( image ) {
                            const canvas = document.createElement('canvas');
                            canvas.width = image.width;
                            canvas.height = image.height; 
                            const context = canvas.getContext('2d',{willReadFrequently: true});
                            context.drawImage( image, 0, 0 );
                            for (let i = 0; i < image.height; i++) {
                                array[i] = [];
                                for (let j = 0; j < image.width; j++) {
                                    array[i][j] = context.getImageData(i, j, 1, 1).data[channel];
                                }
                            }
                            resolve();
                        },undefined,function () {console.error( 'An error happened.' );});
                    });
                    await promise;
                    return array;
                }
            }

            var plane;
            var xSpeed = 0.3;
            var ySpeed = 0.3;
            var zSpeed = 0.3;
            document.addEventListener("keydown", onDocumentKeyDown, false);
            function onDocumentKeyDown(event) {
                var key = event.key;
                console.log(key);
                console.log(event);
                if (key == "e") {
                    camera.position.y += ySpeed;
                } else if (key == "q") {
                    camera.position.y -= ySpeed;
                } else if (key == "a") {
                    camera.position.x -= xSpeed;
                } else if (key == "d") {
                    camera.position.x += xSpeed;
                } else if (key == "w") {
                    camera.position.z -= zSpeed;
                } else if (key == "s") {
                    camera.position.z += zSpeed;
                }
                if (key == "e") {
                    directionalLight.position.y += ySpeed;
                    directionalLight.target.position.y += ySpeed;
                } else if (key == "q") {
                    directionalLight.position.y -= ySpeed;
                    directionalLight.target.position.y -= ySpeed;
                } else if (key == "a") {
                    directionalLight.position.x -= xSpeed;
                    directionalLight.target.position.x -= xSpeed;
                } else if (key == "d") {
                    directionalLight.position.x += xSpeed;
                    directionalLight.target.position.x += xSpeed;
                } else if (key == "w") {
                    directionalLight.position.z -= zSpeed;
                    directionalLight.target.position.z -= zSpeed;
                } else if (key == "s") {
                    directionalLight.position.z += zSpeed;
                    directionalLight.target.position.z += zSpeed;
                }
                plane.position.x = directionalLight.position.x;
                plane.position.y = directionalLight.position.y;
                plane.position.z = directionalLight.position.z;
            };
            function initLoaders(){
                textureLoader = new THREE.TextureLoader();
                objLoader = new OBJLoader();
                mtlLoader = new MTLLoader();
                imageLoader = new ImageLoader();
            }
            function getRandomInt(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min) + min); // The maximum is exclusive and the minimum is inclusive
            }
            //pass the uvAttribute.array here 
            function setUVcoordinates(xOffset,yOffset,uvarray){
                uvarray[0] = xOffset*uvOffset;     uvarray[1] = yOffset*(uvOffset)+uvOffset; //1 
                uvarray[2] = xOffset*(uvOffset)+uvOffset; uvarray[3] = yOffset*(uvOffset)+uvOffset;//2 
                uvarray[4] = xOffset*uvOffset;     uvarray[5] = yOffset*uvOffset;//3 
                uvarray[6] = xOffset*(uvOffset)+uvOffset; uvarray[7] = yOffset*uvOffset;// 4
            }
            function animate() {
                requestAnimationFrame(animate);
                composer.render();
            }
        </script>
    </body>

    </html>