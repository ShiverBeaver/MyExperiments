<DOCTYPE html>
    <html>

    <head>
        <meta charset="utf-8">
        <title>webgl test</title>
        <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
                    "three/": "https://unpkg.com/three@0.149.0/"
                }
            }
        </script>
        <script src="http://mrdoob.github.io/stats.js/build/stats.min.js"></script>

    </head>

    <body>

        <script type="module">
            import * as THREE from 'three';
            import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js'
            import { TextureLoader } from "three/src/loaders/TextureLoader.js";
            import { ImageLoader } from "three/src/loaders/ImageLoader.js";
            import * as BufferGeometryUtils from "three/examples/jsm/utils/BufferGeometryUtils.js";
            import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
            import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
            const delay = ms => new Promise(res => setTimeout(res, ms));
            
            let objLoader, textureLoader, mtlLoader, imageLoader;  
            let scene, camera, renderer, composer;
            let blocksTexture, modelsTexture, waterTexture1, waterTexture2, borderTexture; 
            let blocksMaterial, modelsMaterial, waterMaterial1, waterMaterial2, borderMaterial;
            let waterMesh1, waterMesh2, landscapeMesh;
            let clouds = [];
            let waterfallLayers = [];
            let currentLevel; 
            let ambientLight, directionalLight, lightTarget;
            let uvOffset = 0.125;

            let LevelSize = 40;
            let waterLevel = 4; 
            

            
            const Block = createEnum(['Air','Grass', 'Dirt','Road']);
            currentLevel = 0;
            initLoaders();
            
            await loadLevel(1);
            // Adding stats panel to moniter application statistics
            const stats = new Stats();
            stats.showPanel(0);
            //stats.showPanel(1)
            document.body.appendChild(stats.dom)
            animate();
            async function loadLevel(level){
                initScene();
                let noise = await LoadImageToArray('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/perlin_scale18_detail3.png',1);
                noise = MapRange(noise,getRandomInt(6,6));
                let maxOffset =  noise[0].length - LevelSize;
                let OffsetX = getRandomInt(0,maxOffset);
                let OffsetZ = getRandomInt(0,maxOffset);
                let levelHeightNoise =  [];
                for (let i = 0; i < LevelSize; i++) {
                    levelHeightNoise[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        levelHeightNoise[i][j] = noise[i+OffsetX][j+OffsetZ];
                    }
                }
                let template = await LoadImageToArray('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/testlevel_colored.png',1);
                template = MapRange(template,getRandomInt(0,14));
                maxOffset =  template[0].length - LevelSize;
                OffsetX = getRandomInt(0,maxOffset);
                OffsetZ = getRandomInt(0,maxOffset);
                let levelHeightTemplate =  [];
                for (let i = 0; i < LevelSize; i++) {
                    levelHeightTemplate[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        levelHeightTemplate[i][j] = template[i+OffsetX][j+OffsetZ];
                    }
                }
                
                let villagetemplate = await LoadImageToArray('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/generation/leveltemplates/testlevel_colored.png',0);
                villagetemplate = MapRange(villagetemplate,100);
                console.log(villagetemplate);
                let villagelevelTemplate =  [];
                for (let i = 0; i < LevelSize; i++) {
                    villagelevelTemplate[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        villagelevelTemplate[i][j] = villagetemplate[i+OffsetX][j+OffsetZ];
                    }
                }

                
                let HeightMap =  [];
                for (let i = 0; i < LevelSize; i++) {
                    HeightMap[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        if (villagelevelTemplate[i][j] >0){
                            HeightMap[i][j] = levelHeightTemplate[i][j] + 2;
                        }
                        else{
                            HeightMap[i][j] = levelHeightTemplate[i][j]+levelHeightNoise[i][j];
                        }
                    }
                }
                
                let map =  [];
                for (let i = 0; i < LevelSize; i++) {
                    map[i] = [];
                    for (let j = 0; j < LevelSize; j++) {
                        map[i][j] = []
                        for(let z = 0;z < 100; z++){
                            map[i][j][z] = Block.Air;
                        }
                    }
                }
                for(let i = 0; i < LevelSize; i++){
                    for(let j = 0; j < LevelSize; j++){
                        for(let z = 0; z < HeightMap[i][j]; z++){
                            map[i][j][z] = Block.Dirt;
                        }
                        map[i][j][HeightMap[i][j]]=Block.Grass; 
                    }
                }
                //console.log(map);
                
                loadMeshes();
                function initScene(){
                    /*Camera*/
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color( 0x338BA8 );
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);//100
                    camera.position.x = 20.6;
                    camera.position.y = 15;
                    camera.position.z = 30;

                    camera.rotation.x = -Math.PI/4; //camera.rotation.x = -Math.PI/2 + 0.3;
                    /*Rendering*/
                    renderer = new THREE.WebGLRenderer({antialias:true});
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    renderer.shadowMap.enabled = true;
                    document.body.appendChild(renderer.domElement);
                    composer = new EffectComposer(renderer);
                    composer.addPass(new RenderPass(scene, camera));
                    let bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                    bloomPass.renderToScreen = true;
                    bloomPass.threshold = 0;
                    bloomPass.strength = 0.2;
                    bloomPass.radius = 0;
                    composer.addPass(bloomPass);
                    /*Materials*/
                    blocksTexture = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/texture.png');
                    blocksTexture.minFilter = THREE.NearestFilter;
                    blocksTexture.magFilter = THREE.NearestFilter;
                    blocksMaterial = new THREE.MeshLambertMaterial({map: blocksTexture/*, wireframe:true, color: 0xAAAAAAA*/});
                    waterTexture1 = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/water1.png');
                    waterTexture1.wrapS = THREE.RepeatWrapping;
                    waterTexture1.wrapT = THREE.RepeatWrapping;
                    waterTexture1.repeat.x = LevelSize/2;
                    waterTexture1.repeat.y = LevelSize/2;
                    waterTexture1.minFilter = THREE.NearestFilter;
                    waterTexture1.magFilter = THREE.NearestFilter;
                    waterMaterial1 = new THREE.MeshBasicMaterial({map: waterTexture1, transparent: true, opacity: 0.50});
                    
                    waterTexture2 = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/water2.png');
                    waterTexture2.wrapS = THREE.RepeatWrapping;
                    waterTexture2.wrapT = THREE.RepeatWrapping;
                    waterTexture2.repeat.x = LevelSize/2;
                    waterTexture2.repeat.y = LevelSize/2;
                    waterTexture2.minFilter = THREE.NearestFilter;
                    waterTexture2.magFilter = THREE.NearestFilter;
                    waterMaterial2 = new THREE.MeshBasicMaterial({map: waterTexture2, transparent: true, opacity: 0.55, color: 0xffffff});
                    
                    borderTexture = textureLoader.load('https://raw.githubusercontent.com/ShiverBeaver/MyExperiments/main/textures/clouds.png');
                    borderTexture.minFilter = THREE.NearestFilter;
                    borderTexture.magFilter = THREE.NearestFilter;
                    borderMaterial = new THREE.MeshBasicMaterial({map: borderTexture, transparent: true, opacity: 0.50});

                    /*Lighting*/
                    const color = 0xFFFFFF;
                    const intensity = 0.55;
                    ambientLight = new THREE.AmbientLight(color, intensity);
                    scene.add(ambientLight);
                    directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.x = camera.position.x + 10;
                    directionalLight.position.y = camera.position.y + 10;;
                    directionalLight.position.z = camera.position.z - 30;;
                    
                    directionalLight.castShadow = true;
                    directionalLight.shadow.mapSize.width = 1024*1; 
                    directionalLight.shadow.mapSize.height = 1024*1; 
                    directionalLight.shadow.camera.near = 0.5; 
                    directionalLight.shadow.camera.far = 128; 
                    //console.log(directionalLight.shadow.camera);
                    let lightradius = 200; //60
                    directionalLight.shadow.camera.right = lightradius; 
                    directionalLight.shadow.camera.top = lightradius; 
                    directionalLight.shadow.camera.bottom = -lightradius;
                    directionalLight.shadow.camera.left = -lightradius;
                    directionalLight.target = new THREE.Object3D();
                    
                    scene.add(directionalLight.target);
                    scene.add(directionalLight);
                    directionalLight.position.x += 10;
                    directionalLight.target.position.x += 10;
                    directionalLight.target.position.z += 20;
                }
                function loadMeshes(){
                    let planegeometry = new THREE.PlaneGeometry(); 
                    let meshesArray = [];
                    let uvAttribute = planegeometry.getAttribute("uv");
                    let uvArray = uvAttribute.array;
                    //uvAttribute.needsUpdate = true;
                    
                    let testgrassmat = new THREE.MeshStandardMaterial({color: 0x009900, wireframe: true}); 
                    let testdirtmat = new THREE.MeshStandardMaterial({color: 0x964B00, wireframe: true}); 
                    let testwhitemat = new THREE.MeshStandardMaterial({color: 0xAAAAAA, wireframe: false}); 

                    //helper function that setting uv for side planes of block
                    function pickSideUV(i,j,z,geometry){
                        const uvAttribute = geometry.getAttribute("uv");
                        const uvArray = uvAttribute.array;      
                        switch (map[i][j][z]){
                            case Block.Grass:
                                setUVcoordinates(0,7,uvArray);
                                break;
                            case Block.Dirt:
                                setUVcoordinates(1,7,uvArray);
                                if (Math.random() < stonecoef) setUVcoordinates(2,7,uvArray);
                            break;
                        }
                    }
                    let stonecoef = 0.10;
                    for (let i = 0; i < LevelSize; i++) {
                        for (let j = 0; j < LevelSize; j++) {
                            for (let z = 0; z < 100; z++){
                                if(map[i][j][z]==undefined || map[i][j][z]==Block.Air){continue}
                                if(map[i][j][z+1]==Block.Air || map[i][j][z+1]==undefined){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateX(-Math.PI/2);
                                    planegeometry.translate(i,z+0.5,j);  
                                    const uvAttribute = planegeometry.getAttribute("uv");
                                    const uvArray = uvAttribute.array;      
                                    switch (map[i][j][z]){
                                        case Block.Grass:
                                            let offset = Math.random()>0.5?0:getRandomInt(1,4);
                                            setUVcoordinates(4+(z<4?0:offset),6,uvArray);
                                            break;
                                    }
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i][j+1]==undefined || map[i][j+1][z]==Block.Air){ //смотрит в камеру по дефолту
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(0);
                                    planegeometry.translate(i,z,j+0.5);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i][j-1]==undefined || map[i][j-1][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(Math.PI);
                                    planegeometry.translate(i,z,j-0.5);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i+1]==undefined || map[i+1][j][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(Math.PI/2);
                                    planegeometry.translate(i+0.5,z,j);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                                if(map[i-1]==undefined || map[i-1][j][z]==Block.Air){
                                    let planegeometry = new THREE.PlaneGeometry(); 
                                    planegeometry.rotateY(-Math.PI/2);
                                    planegeometry.translate(i-0.5,z,j);  
                                    pickSideUV(i,j,z,planegeometry);
                                    meshesArray.push(planegeometry);
                                }
                            }
                        }
                    }
                    let landscapemodel = BufferGeometryUtils.mergeBufferGeometries(meshesArray);
                    let landscapeMesh = new THREE.Mesh(landscapemodel, blocksMaterial);
                    landscapeMesh.receiveShadow = true;
                    landscapeMesh.castShadow = true;
                    scene.add(landscapeMesh);
                    console.info(new Blob([JSON.stringify(map)]).size);

                    
                    let waterGeometry1 = new THREE.PlaneGeometry();
                    waterGeometry1.scale(LevelSize,LevelSize,LevelSize);
                    waterGeometry1.rotateX(-Math.PI/2);
                   

                    let waterGeometry2 = new THREE.PlaneGeometry();
                    waterGeometry2.scale(LevelSize,LevelSize,LevelSize);
                    waterGeometry2.rotateX(-Math.PI/2);
                    

                    waterMesh1 = new THREE.Mesh(waterGeometry1,waterMaterial1);
                    waterMesh2 = new THREE.Mesh(waterGeometry2,waterMaterial2);
                    waterMesh1.position.set(LevelSize/2-0.5,0,LevelSize/2-0.5);
                    waterMesh2.position.set(LevelSize/2-0.5,0,LevelSize/2-0.5);

                    waterMesh1.position.y = waterLevel+0.3;
                    waterMesh2.position.y = waterLevel-1+0.3;
                    waterMesh1.receiveShadow = true;
                    waterMesh1.castShadow = true;
                    waterMesh2.receiveShadow = true;
                    waterMesh2.castShadow = true;
                    scene.add(waterMesh1);
                    scene.add(waterMesh2);
                    animateWater();

                    let waterfallGeometries = [[],[],[],[]];

                    for (let i = 0; i < LevelSize; i++) {
                        if(map[i][LevelSize-1][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(0);
                                planegeometry.translate(i,0.3-0.5,LevelSize-0.499);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                            }
                        }
                        if(map[i][0][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(Math.PI);
                                planegeometry.translate(i,0.3-0.5,-0.501);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                                
                            }
                        }
                    }
                    for (let j = 0; j < LevelSize; j++) {
                        if(map[LevelSize-1][j][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(Math.PI/2);
                                planegeometry.translate(LevelSize-0.499,0.3-0.5,j);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                            }
                        }
                        if(map[0][j][waterLevel]==Block.Air){
                            for (let z = 0; z<4; z++){
                                let planegeometry = new THREE.PlaneGeometry(); 
                                planegeometry.rotateY(-Math.PI/2);
                                planegeometry.translate(-0.501,0.3-0.5,j);  
                                let uvAttribute = planegeometry.getAttribute("uv");
                                let uvArray = uvAttribute.array;
                                setUVcoordinates(getRandomInt(0,3),3-z,uvArray);
                                waterfallGeometries[z].push(planegeometry);
                                
                            }
                        }
                    }

                    for (let z = 0; z<4; z++){
                        if(waterfallGeometries[z].length>0){
                            waterfallLayers[z] = new THREE.Mesh(BufferGeometryUtils.mergeBufferGeometries(waterfallGeometries[z]),borderMaterial);
                            waterfallLayers[z].position.y = waterLevel-z;
                            scene.add(waterfallLayers[z]);
                        }
                    }
                    animateWaterFall();
                }

                function MapRange(array,layersNumber,maxNumber = 255){
                    let coefficient = layersNumber/maxNumber;
                    let newarray = [];
                    for (let i = 0; i < array.length; i++) {
                        newarray[i] = [];
                        for (let j = 0; j < array[i].length; j++) {
                            newarray[i][j] = Math.round(array[i][j]*coefficient);
                        }
                    }
                    return newarray;
                }

                //channel r - 0   g - 1   b - 2  a  - 3
                async function LoadImageToArray(url,channel=0){
                    let array = []
                    let promise = new Promise(function(resolve, reject) {
                        imageLoader.load(url,
                        function ( image ) {
                            const canvas = document.createElement('canvas');
                            canvas.width = image.width;
                            canvas.height = image.height; 
                            const context = canvas.getContext('2d',{willReadFrequently: true});
                            context.drawImage( image, 0, 0 );
                            for (let i = 0; i < image.height; i++) {
                                array[i] = [];
                                for (let j = 0; j < image.width; j++) {
                                    array[i][j] = context.getImageData(i, j, 1, 1).data[channel];
                                }
                            }
                            resolve();
                        },undefined,function () {console.error( 'An error happened.' );});
                    });
                    await promise;
                    return array;
                }
            }


            var plane;
            var xSpeed = 0.6;
            var ySpeed = 0.6;
            var zSpeed = 0.6;
            document.addEventListener("keydown", onDocumentKeyDown, false);
            function onDocumentKeyDown(event) {
                var key = event.key;
                console.log(key);
                console.log(event);
                if (key == "e") {
                    camera.position.y += ySpeed;
                } else if (key == "q") {
                    camera.position.y -= ySpeed;
                } else if (key == "a") {
                    camera.position.x -= xSpeed;
                } else if (key == "d") {
                    camera.position.x += xSpeed;
                } else if (key == "w") {
                    camera.position.z -= zSpeed;
                } else if (key == "s") {
                    camera.position.z += zSpeed;
                }
                if (key == "e") {
                    directionalLight.position.y += ySpeed;
                    directionalLight.target.position.y += ySpeed;
                } else if (key == "q") {
                    directionalLight.position.y -= ySpeed;
                    directionalLight.target.position.y -= ySpeed;
                } else if (key == "a") {
                    directionalLight.position.x -= xSpeed;
                    directionalLight.target.position.x -= xSpeed;
                } else if (key == "d") {
                    directionalLight.position.x += xSpeed;
                    directionalLight.target.position.x += xSpeed;
                } else if (key == "w") {
                    directionalLight.position.z -= zSpeed;
                    directionalLight.target.position.z -= zSpeed;
                } else if (key == "s") {
                    directionalLight.position.z += zSpeed;
                    directionalLight.target.position.z += zSpeed;
                }
            };


            function initLoaders(){
                textureLoader = new THREE.TextureLoader();
                objLoader = new OBJLoader();
                mtlLoader = new MTLLoader();
                imageLoader = new ImageLoader();
            }

            // The maximum is exclusive and the minimum is inclusive
            function getRandomInt(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min) + min); 
            }
            function createEnum(values) {
                const enumObject = {};
                for (const val of values) {
                    enumObject[val] = val;
                }
                return Object.freeze(enumObject);
            }
            //pass the uvAttribute.array here 
            function setUVcoordinates(xOffset,yOffset,uvarray){
                uvarray[0] = xOffset*uvOffset;            uvarray[1] = yOffset*(uvOffset)+uvOffset; //1 
                uvarray[2] = xOffset*(uvOffset)+uvOffset; uvarray[3] = yOffset*(uvOffset)+uvOffset;//2 
                uvarray[4] = xOffset*uvOffset;            uvarray[5] = yOffset*uvOffset;//3 
                uvarray[6] = xOffset*(uvOffset)+uvOffset; uvarray[7] = yOffset*uvOffset;// 4
            }

            //rotating constantly rotating water texture 90 degrees to make it look animated 
            async function animateWater(){
                while(true){
                    waterMesh1.rotation.y += Math.PI/2;
                    waterMesh2.rotation.y += Math.PI/2;
                    await delay(400);
                }
            }
            async function animateWaterFall(){
                while(true){
                    await delay(400);
                    for(let i = 0; i<4; i++){
                        waterfallLayers[i].position.y -= 1;
                        if(waterfallLayers[i].position.y < waterLevel-3)
                        {
                            waterfallLayers[i].position.y += 4;
                        }
                    }
                }
            }
            function animate() {
                requestAnimationFrame(animate);
                stats.begin();
                composer.render();
                stats.end();

            }
        </script>
    </body>

    </html>